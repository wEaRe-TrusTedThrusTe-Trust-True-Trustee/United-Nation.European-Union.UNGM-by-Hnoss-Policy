<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vollbild Pixel Warp mit Gravitation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
        }
        .vignette {
            position: absolute;
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            background: radial-gradient(circle, transparent 10%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
        }
        .pixel-label {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #0ff;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.7;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div class="vignette"></div>
    <div class="pixel-label">Vollbild Warp mit Gravitation aktiv</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, clock;
        let pixelGroup = new THREE.Group();
        let stars;
        let starVelocities = [];
        let mouseX = 0, mouseY = 0;

        const PIXEL_SIZE = 1.5;
        const CRYSTAL_COUNT = 120;
        const STAR_COUNT = 5000;
        const TUNNEL_Z = 1500;
        const GRAVITY = 800;        // Starke Gravitation
        const SMOOTHNESS = 0.88;    // Mehr Dynamik
        const VORTEX_POWER = 0.6;   // Wirbel-Stärke

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 200, 1200);

            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 300;

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            clock = new THREE.Clock();

            createPixelCrystals();
            createPixelStars();
            
            scene.add(pixelGroup);

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', (e) => {
                mouseX = (e.clientX - window.innerWidth / 2) * 0.06;
                mouseY = (e.clientY - window.innerHeight / 2) * 0.06;
            });

            animate();
        }

        function createPixelCrystals() {
            const boxGeo = new THREE.BoxGeometry(PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
            
            for (let i = 0; i < CRYSTAL_COUNT; i++) {
                const crystal = new THREE.Group();
                const color = new THREE.Color();
                color.setHSL(0.5 + Math.random() * 0.1, 1.0, 0.5);
                const mat = new THREE.MeshBasicMaterial({ color: color });

                const positions = [
                    [0,2,0], [0,-2,0], [1,0,0], [-1,0,0], [0,0,1], [0,0,-1],
                    [1,1,0], [-1,1,0], [0,1,1], [0,1,-1],
                    [1,-1,0], [-1,-1,0], [0,-1,1], [0,-1,-1]
                ];

                positions.forEach(pos => {
                    const pixel = new THREE.Mesh(boxGeo, mat);
                    pixel.position.set(pos[0]*PIXEL_SIZE, pos[1]*PIXEL_SIZE, pos[2]*PIXEL_SIZE);
                    crystal.add(pixel);
                });

                resetObject(crystal, true);
                pixelGroup.add(crystal);
            }
        }

        function createPixelStars() {
            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(STAR_COUNT * 3);
            
            starVelocities = [];
            
            for (let i = 0; i < STAR_COUNT; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 400;
                pos[i * 3] = Math.cos(angle) * radius;
                pos[i * 3 + 1] = Math.sin(angle) * radius;
                pos[i * 3 + 2] = Math.random() * -TUNNEL_Z;
                
                starVelocities.push({
                    vx: (Math.random() - 0.5) * 100,
                    vy: Math.random() * -150 - 80,
                    vz: 300 + Math.random() * 500,
                    mass: 0.2 + Math.random() * 2.8,
                    wobble: Math.random() * Math.PI * 2
                });
            }

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            
            const mat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                sizeAttenuation: false
            });

            stars = new THREE.Points(geo, mat);
            scene.add(stars);
        }

        function resetObject(obj, initial = false) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 250;
            obj.position.x = Math.cos(angle) * radius;
            obj.position.y = Math.sin(angle) * radius;
            obj.position.z = initial ? (Math.random() * -TUNNEL_Z) : -TUNNEL_Z;
            obj.userData.speed = 400 + Math.random() * 600;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            camera.position.x += (mouseX - camera.position.x) * 0.05;
            camera.position.y += (-mouseY - camera.position.y) * 0.05;
            
            camera.position.x += Math.sin(time * 50) * 0.5;
            camera.position.y += Math.cos(time * 50) * 0.5;

            pixelGroup.children.forEach(c => {
                c.position.z += c.userData.speed * delta;
                c.rotation.y += 0.05;
                c.rotation.x += 0.02;
                if (c.position.z > 400) resetObject(c);
            });

            // GRAVITATIONS-PHYSIK MIT ALLEN EFFEKTEN
            const starPos = stars.geometry.attributes.position.array;
            for (let i = 0; i < STAR_COUNT; i++) {
                const vel = starVelocities[i];
                
                // 1. GRAVITATION nach unten
                vel.vy -= GRAVITY * delta * vel.mass;
                
                // 2. ZENTRIPETALKRAFT (Schwarzes Loch)
                const centerPullX = -starPos[i * 3] * 0.4;
                const centerPullY = -starPos[i * 3 + 1] * 0.4;
                vel.vx += centerPullX * delta * 2;
                vel.vy += centerPullY * delta * 2;
                
                // 3. WIRBEL-EFFEKT (Spiral-Rotation)
                const distFromCenter = Math.sqrt(starPos[i * 3]**2 + starPos[i * 3 + 1]**2);
                const vortexStrength = Math.min(VORTEX_POWER, 250 / (distFromCenter + 1));
                vel.vx += -starPos[i * 3 + 1] * vortexStrength;
                vel.vy += starPos[i * 3] * vortexStrength;
                
                // 4. ORGANISCHES WOBBLE
                vel.wobble += delta * 3;
                vel.vx += Math.sin(vel.wobble) * 10 * delta;
                vel.vy += Math.cos(vel.wobble * 1.3) * 10 * delta;
                
                // 5. SMOOTH DÄMPFUNG
                vel.vx *= SMOOTHNESS;
                vel.vy *= SMOOTHNESS;
                
                // 6. POSITION UPDATE
                starPos[i * 3] += vel.vx * delta;
                starPos[i * 3 + 1] += vel.vy * delta;
                starPos[i * 3 + 2] += vel.vz * delta;
                
                // 7. BOUNCE
                if (Math.abs(starPos[i * 3]) > 500) {
                    vel.vx *= -0.7;
                    starPos[i * 3] = Math.sign(starPos[i * 3]) * 500;
                }
                if (Math.abs(starPos[i * 3 + 1]) > 500) {
                    vel.vy *= -0.7;
                    starPos[i * 3 + 1] = Math.sign(starPos[i * 3 + 1]) * 500;
                }
                
                // 8. WARP-RESET  
                if (starPos[i * 3 + 2] > 400) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = Math.random() * 400;
                    starPos[i * 3] = Math.cos(angle) * radius;
                    starPos[i * 3 + 1] = Math.sin(angle) * radius;
                    starPos[i * 3 + 2] = -TUNNEL_Z;
                    
                    vel.vx = (Math.random() - 0.5) * 100;
                    vel.vy = Math.random() * -150 - 80;
                    vel.vz = 300 + Math.random() * 500;
                    vel.mass = 0.2 + Math.random() * 2.8;
                    vel.wobble = Math.random() * Math.PI * 2;
                }
            }
            stars.geometry.attributes.position.needsUpdate = true;

            camera.fov = 85 + Math.sin(time * 0.5) * 5;
            camera.updateProjectionMatrix();

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
